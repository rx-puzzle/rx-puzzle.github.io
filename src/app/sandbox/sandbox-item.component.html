<div
  class="panel-header"
  matRipple
  #headerRipple="matRipple"
  [matRippleDisabled]="!isExpandable"
  (click)="onPanelHeaderClick($event)"
>
  <rxp-marble-sequence
    *ngIf="isSequence"
    [isEditable]="isEditable"
    [marbles]="marbles"
    (marblesChange)="onSequenceChange($event)"
    [fixedLength]="sandbox.options.marblesPerSequence"
    [marbleSize]="cssNum('--marble-size')"
    [timelineColor]="cssStr('--input-timeline-color')"
    [progress]="1"
    (touchmove)="$event.preventDefault()"
    (dragStarted)="headerRipple.fadeOutAll()"
  ></rxp-marble-sequence>
  <div *ngIf="isSequence" class="left-touch-zone"></div>
  <div *ngIf="isSequence" class="right-touch-zone"></div>
  <div *ngIf="item.type === 'transformer'" class="transformer-header">
    <div>{{ operatorName }}<span>{{ operatorParen }}</span></div>
    <button
      *ngIf="!isPictureMode"
      mat-icon-button
      [disabled]="isPlaying"
      (mousedown)="$event.stopPropagation()"
      (touchstart)="$event.stopPropagation()"
      onclick="this.blur()"
      (click)="onOperatorSelectionButtonClick($event)"
    >
      <mat-icon>menu_open</mat-icon>
    </button>
  </div>
</div>

<div class="panel-content">
  <div *ngIf="item.type === 'transformer'" class="transformer-content">
    <div class="description">
      <ng-container *ngIf="true; then description"></ng-container>
    </div>
    <div class="action-bar">
      <a
        mat-button
        target="_blank"
        rel="noopener noreferrer nofollow"
        onclick="this.blur()"
        [attr.href]="operatorHref"
      >
        LEARN MORE
      </a>
    </div>
  </div>
  <mat-divider></mat-divider>
  <div *ngIf="isEditable" class="common-action-bar">
    <button mat-icon-button [disabled]="!canRemove" (click)="remove()">
      <mat-icon>remove_circle_outline</mat-icon>
    </button>
    <button
      mat-icon-button
      [disabled]="!canAddSequence"
      (click)="addSequence()"
    >
      <mat-icon svgIcon="add-sequence"></mat-icon>
    </button>
    <button
      mat-icon-button
      [disabled]="!canAddTransformer"
      (click)="addTransformer()"
    >
      <mat-icon svgIcon="add-transformer"></mat-icon>
    </button>
    <span style="flex: 1 0"></span>
    <button mat-icon-button [disabled]="!canMoveUp" (click)="moveUp()">
      <mat-icon>arrow_drop_up</mat-icon>
    </button>
    <button mat-icon-button [disabled]="!canMoveDown" (click)="moveDown()">
      <mat-icon>arrow_drop_down</mat-icon>
    </button>
  </div>
</div>

<div class="panel-footer">
  <div *ngIf="isTransformer" class="transformer-output">
    <mat-divider></mat-divider>
    <rxp-marble-sequence
      [isEditable]="false"
      [marbles]="getTransformerOutput()"
      [fixedLength]="sandbox.options.marblesPerSequence"
      [marbleSize]="cssNum('--marble-size')"
      [timelineColor]="cssStr('--output-timeline-color')"
      [progress]="playProgress"
    >
    </rxp-marble-sequence>
  </div>
</div>

<ng-template #description>
  <ng-container [ngSwitch]="operatorName">
    <p *ngSwitchCase="'race'">
      Returns an Observable that mirrors the first source Observable to emit an
      item.
    </p>
    <p *ngSwitchCase="'scan'">
      Useful for encapsulating and managing state. Applies an accumulator (or
      "reducer function") to each value from the source after an initial state
      is established -- either via a seed value (second argument), or from the
      first value from the source.
    </p>
    <p *ngSwitchCase="'pairwise'">
      Groups pairs of consecutive emissions together and emits them as an array
      of two values.
    </p>
    <p *ngSwitchCase="'bufferCount'">
      Buffers the source Observable values until the size hits the maximum
      bufferSize given.
    </p>
    <p *ngSwitchCase="'bufferTime'">
      Buffers the source Observable values for a specific time period.
    </p>
    <p *ngSwitchCase="'sampleTime'">
      Emits the most recently emitted value from the source Observable within
      periodic time intervals.
    </p>
    <p *ngSwitchCase="'throttleTime'">
      Emits a value from the source Observable, then ignores subsequent source
      values for duration milliseconds, then repeats this process.
    </p>
    <p *ngSwitchCase="'auditTime'">
      Ignores source values for duration milliseconds, then emits the most
      recent value from the source Observable, then repeats this process.
    </p>
    <p *ngSwitchCase="'debounceTime'">
      Emits a notification from the source Observable only after a particular
      time span has passed without another source emission.
    </p>
    <p *ngSwitchCase="'distinct'">
      Returns an Observable that emits all items emitted by the source
      Observable that are distinct by comparison from previous items.
    </p>
    <p *ngSwitchCase="'distinctUntilKeyChanged'">
      Returns an Observable that emits all items emitted by the source
      Observable that are distinct by comparison from the previous item, using a
      property accessed by using the key provided to check if the two items are
      distinct.
    </p>
    <p *ngSwitchCase="'withLatestFrom'">
      Combines the source Observable with other Observables to create an
      Observable whose values are calculated from the latest values of each,
      only when the source emits.
    </p>
    <p *ngSwitchCase="'concatMap'">
      Projects each source value to an Observable which is merged in the output
      Observable, in a serialized fashion waiting for each one to complete
      before merging the next.
    </p>
    <p *ngSwitchCase="'mergeMap'">
      Projects each source value to an Observable which is merged in the output
      Observable.
    </p>
    <p *ngSwitchCase="'switchMap'">
      Projects each source value to an Observable which is merged in the output
      Observable, emitting values only from the most recently projected
      Observable.
    </p>
    <p *ngSwitchCase="'exhaustMap'">
      Projects each source value to an Observable which is merged in the output
      Observable only if the previous projected Observable has completed.
    </p>
    <p *ngSwitchCase="'buffer'">
      Buffers the source Observable values until closingNotifier emits.
    </p>
    <p *ngSwitchCase="'sample'">
      Emits the most recently emitted value from the source Observable whenever
      another Observable, the notifier, emits.
    </p>
    <p *ngSwitchCase="'throttle'">
      Emits a value from the source Observable, then ignores subsequent source
      values for a duration determined by another Observable, then repeats this
      process.
    </p>
    <p *ngSwitchCase="'audit'">
      Ignores source values for a duration determined by another Observable,
      then emits the most recent value from the source Observable, then repeats
      this process.
    </p>
    <p *ngSwitchCase="'debounce'">
      Emits a notification from the source Observable only after a particular
      time span determined by another Observable has passed without another
      source emission.
    </p>
    <p *ngSwitchCase="'skipUntil'">
      Returns an Observable that skips items emitted by the source Observable
      until a second Observable emits an item.
    </p>
    <p *ngSwitchCase="'takeUntil'">
      Emits the values emitted by the source Observable until a notifier
      Observable emits a value.
    </p>
    <p *ngSwitchCase="'concat'">
      Creates an output Observable which sequentially emits all values from the
      first given Observable and then moves on to the next.
    </p>
    <p *ngSwitchCase="'merge'">
      Creates an output Observable which concurrently emits all values from
      every given input Observable.
    </p>
    <p *ngSwitchCase="'zip'">
      Combines multiple Observables to create an Observable whose values are
      calculated from the values, in order, of each of its input Observables.
    </p>
    <p *ngSwitchCase="'combineLatest'">
      Combines multiple Observables to create an Observable whose values are
      calculated from the latest values of each of its input Observables.
    </p>
    <p *ngSwitchDefault>No Description.</p>
  </ng-container>
</ng-template>
